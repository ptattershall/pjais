import { useEffect, useCallback, useRef } from 'react';
import { useQueryClient } from '@tanstack/react-query';
import { 
  usePersonaMemories, 
  useMemories, 
  useMemory,
  useMemoryStats,
  useMemorySearch
} from './useSqliteMemories';
import { useEventSubscription, useEventSystem, type ReceivedEvent } from './useEventSystem';
import type { MemoryListRequest, MemoryResponse } from '../../shared/ipc-contracts';

/**
 * Plugin access options for memory events
 */
const DEFAULT_ACCESS_OPTIONS = {
  pluginId: 'memory-explorer',
  accessToken: 'internal-system-token', // This would be generated by the system
  requiredPermissions: ['memory.read', 'memory.write']
};

/**
 * Reactive wrapper for usePersonaMemories that auto-updates on memory events
 */
export function useReactivePersonaMemories(personaId: number, limit?: number) {
  const baseQuery = usePersonaMemories(personaId, limit);
  const personaIdRef = useRef(personaId);
  
  // Update ref when personaId changes
  useEffect(() => {
    personaIdRef.current = personaId;
  }, [personaId]);

  // Handle memory added events
  const { subscribe: subscribeToAdded, unsubscribe: unsubscribeFromAdded } = useEventSubscription(
    'memory.added',
    DEFAULT_ACCESS_OPTIONS,
    useCallback((event: ReceivedEvent) => {
      if (event.payload?.personaId === personaIdRef.current) {
        baseQuery.refetch();
      }
    }, [baseQuery])
  );

  // Handle memory updated events
  const { subscribe: subscribeToUpdated, unsubscribe: unsubscribeFromUpdated } = useEventSubscription(
    'memory.updated', 
    DEFAULT_ACCESS_OPTIONS,
    useCallback((event: ReceivedEvent) => {
      if (event.payload?.personaId === personaIdRef.current) {
        baseQuery.refetch();
      }
    }, [baseQuery])
  );

  // Handle memory deleted events
  const { subscribe: subscribeToDeleted, unsubscribe: unsubscribeFromDeleted } = useEventSubscription(
    'memory.deleted',
    DEFAULT_ACCESS_OPTIONS, 
    useCallback((event: ReceivedEvent) => {
      if (event.payload?.personaId === personaIdRef.current) {
        baseQuery.refetch();
      }
    }, [baseQuery])
  );

  // Subscribe to events on mount
  useEffect(() => {
    if (personaId) {
      subscribeToAdded();
      subscribeToUpdated();
      subscribeToDeleted();
    }

    return () => {
      unsubscribeFromAdded();
      unsubscribeFromUpdated();
      unsubscribeFromDeleted();
    };
  }, [personaId, subscribeToAdded, subscribeToUpdated, subscribeToDeleted, unsubscribeFromAdded, unsubscribeFromUpdated, unsubscribeFromDeleted]);

  return {
    ...baseQuery,
    isReactive: true,
    eventSubscriptions: {
      memoryAdded: subscribeToAdded,
      memoryUpdated: subscribeToUpdated,
      memoryDeleted: subscribeToDeleted
    }
  };
}

/**
 * Reactive wrapper for useMemories that auto-updates on memory events
 */
export function useReactiveMemories(params?: MemoryListRequest) {
  const baseQuery = useMemories(params);
  const paramsRef = useRef(params);
  
  // Update ref when params change
  useEffect(() => {
    paramsRef.current = params;
  }, [params]);

  // Handle memory events with broader scope
  const { subscribe: subscribeToAdded } = useEventSubscription(
    'memory.added',
    DEFAULT_ACCESS_OPTIONS,
    useCallback(() => {
      // Refetch for all memory events since we're not filtering by persona
      baseQuery.refetch();
    }, [baseQuery])
  );

  const { subscribe: subscribeToUpdated } = useEventSubscription(
    'memory.updated',
    DEFAULT_ACCESS_OPTIONS,
    useCallback(() => {
      baseQuery.refetch();
    }, [baseQuery])
  );

  const { subscribe: subscribeToDeleted } = useEventSubscription(
    'memory.deleted',
    DEFAULT_ACCESS_OPTIONS,
    useCallback(() => {
      baseQuery.refetch();
    }, [baseQuery])
  );

  // Subscribe on mount
  useEffect(() => {
    subscribeToAdded();
    subscribeToUpdated();
    subscribeToDeleted();
  }, [subscribeToAdded, subscribeToUpdated, subscribeToDeleted]);

  return {
    ...baseQuery,
    isReactive: true
  };
}

/**
 * Reactive wrapper for useMemory that invalidates cache on updates
 */
export function useReactiveMemory(id: number) {
  const queryClient = useQueryClient();
  const baseQuery = useMemory(id);
  const idRef = useRef(id);

  // Update ref when id changes
  useEffect(() => {
    idRef.current = id;
  }, [id]);

  // Handle memory updated events for this specific memory
  const { subscribe: subscribeToUpdated } = useEventSubscription(
    'memory.updated',
    DEFAULT_ACCESS_OPTIONS,
    useCallback((event: ReceivedEvent) => {
      if (event.payload?.memoryId === idRef.current) {
        baseQuery.refetch();
      }
    }, [baseQuery])
  );

  // Handle memory deleted events for this specific memory
  const { subscribe: subscribeToDeleted } = useEventSubscription(
    'memory.deleted',
    DEFAULT_ACCESS_OPTIONS,
    useCallback((event: ReceivedEvent) => {
      if (event.payload?.memoryId === idRef.current) {
        // Remove from query cache since it's deleted
        queryClient.removeQueries({ queryKey: ['memories', idRef.current] });
      }
    }, [queryClient])
  );

  // Subscribe on mount
  useEffect(() => {
    if (id) {
      subscribeToUpdated();
      subscribeToDeleted();
    }
  }, [id, subscribeToUpdated, subscribeToDeleted]);

  return {
    ...baseQuery,
    isReactive: true
  };
}

/**
 * Reactive wrapper for useMemoryStats that updates on memory changes
 */
export function useReactiveMemoryStats(personaId?: string) {
  const baseQuery = useMemoryStats(personaId);
  const personaIdRef = useRef(personaId);

  // Update ref when personaId changes
  useEffect(() => {
    personaIdRef.current = personaId;
  }, [personaId]);

  // Handle memory events that would affect stats
  const { subscribe: subscribeToEvents } = useEventSubscription(
    'memory.added',
    DEFAULT_ACCESS_OPTIONS,
    useCallback((event: ReceivedEvent) => {
      // Refresh stats if no persona filter or if event matches persona
      if (!personaIdRef.current || event.payload?.personaId === personaIdRef.current) {
        baseQuery.refetch();
      }
    }, [baseQuery])
  );

  // Subscribe to multiple event types
  useEffect(() => {
    subscribeToEvents();
  }, [subscribeToEvents]);

  return {
    ...baseQuery,
    isReactive: true
  };
}

/**
 * Reactive wrapper for useMemorySearch that updates search results on memory changes
 */
export function useReactiveMemorySearch(personaId?: string, searchTerm?: string) {
  const baseQuery = useMemorySearch(personaId, searchTerm);
  const personaIdRef = useRef(personaId);
  const searchTermRef = useRef(searchTerm);

  // Update refs when values change
  useEffect(() => {
    personaIdRef.current = personaId;
    searchTermRef.current = searchTerm;
  }, [personaId, searchTerm]);

  // Handle memory events that would affect search results
  const { subscribe: subscribeToSearchEvents } = useEventSubscription(
    'memory.added',
    DEFAULT_ACCESS_OPTIONS,
    useCallback((event: ReceivedEvent) => {
      // Only refresh if we're actively searching and the event matches our criteria
      if (searchTermRef.current && searchTermRef.current.trim()) {
        if (!personaIdRef.current || event.payload?.personaId === personaIdRef.current) {
          baseQuery.refetch();
        }
      }
    }, [baseQuery])
  );

  // Subscribe on mount and when search parameters change
  useEffect(() => {
    if (searchTerm && searchTerm.trim()) {
      subscribeToSearchEvents();
    }
  }, [searchTerm, subscribeToSearchEvents]);

  return {
    ...baseQuery,
    isReactive: true,
    searchTerm,
    isSearching: Boolean(searchTerm && searchTerm.trim())
  };
}

/**
 * Hook that provides reactive memory operations with event publishing
 */
export function useReactiveMemoryOperations() {
  const { publish } = useEventSystem();
  const queryClient = useQueryClient();

  const publishMemoryEvent = useCallback(async (
    eventType: 'memory.added' | 'memory.updated' | 'memory.deleted',
    memory: MemoryResponse | { id: number; personaId?: number }
  ) => {
    try {
      await publish(eventType, {
        memoryId: memory.id,
        personaId: 'persona_id' in memory ? memory.persona_id : memory.personaId,
        timestamp: new Date().toISOString(),
        ...('content' in memory ? { content: memory.content } : {})
      });
    } catch (error) {
      console.error(`Failed to publish ${eventType} event:`, error);
    }
  }, [publish]);

  return {
    publishMemoryAdded: (memory: MemoryResponse) => publishMemoryEvent('memory.added', memory),
    publishMemoryUpdated: (memory: MemoryResponse) => publishMemoryEvent('memory.updated', memory),
    publishMemoryDeleted: (memory: { id: number; personaId?: number }) => publishMemoryEvent('memory.deleted', memory),
    
    // Convenience method to refresh all memory-related queries
    refreshAllMemoryQueries: useCallback(() => {
      queryClient.invalidateQueries({ queryKey: ['memories'] });
      queryClient.invalidateQueries({ queryKey: ['memoryStats'] });
      queryClient.invalidateQueries({ queryKey: ['memoryAnalytics'] });
      queryClient.invalidateQueries({ queryKey: ['memorySearch'] });
    }, [queryClient])
  };
}

/**
 * Enhanced hook that provides real-time memory notifications
 */
export function useMemoryNotifications(options?: { 
  showToasts?: boolean;
  onMemoryAdded?: (memory: MemoryResponse) => void;
  onMemoryUpdated?: (memory: MemoryResponse) => void;
  onMemoryDeleted?: (memoryId: number) => void;
}) {
  const { onMemoryAdded, onMemoryUpdated, onMemoryDeleted } = options || {};

  // Subscribe to memory added events
  useEventSubscription(
    'memory.added',
    DEFAULT_ACCESS_OPTIONS,
    useCallback((event: ReceivedEvent) => {
      if (options?.showToasts) {
        console.log('Memory added:', event.payload);
        // Here you could integrate with a toast library
      }
      onMemoryAdded?.(event.payload);
    }, [onMemoryAdded, options?.showToasts])
  );

  // Subscribe to memory updated events  
  useEventSubscription(
    'memory.updated',
    DEFAULT_ACCESS_OPTIONS,
    useCallback((event: ReceivedEvent) => {
      if (options?.showToasts) {
        console.log('Memory updated:', event.payload);
      }
      onMemoryUpdated?.(event.payload);
    }, [onMemoryUpdated, options?.showToasts])
  );

  // Subscribe to memory deleted events
  useEventSubscription(
    'memory.deleted',
    DEFAULT_ACCESS_OPTIONS,
    useCallback((event: ReceivedEvent) => {
      if (options?.showToasts) {
        console.log('Memory deleted:', event.payload);
      }
      onMemoryDeleted?.(event.payload.memoryId);
    }, [onMemoryDeleted, options?.showToasts])
  );

  return {
    // Returns subscription status or other utility methods if needed
    isListening: true
  };
}
