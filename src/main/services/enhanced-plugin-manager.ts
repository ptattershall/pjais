import { EventEmitter } from 'events';
import { PluginManager } from './plugin-manager';
import { PluginLifecycleManager } from './plugin-lifecycle-manager';
import { PluginSandbox } from './plugin-sandbox';
import { PluginCodeSigningService } from './plugin-code-signing';
import { SecurityEventLogger } from './security-event-logger';
import { HealthMonitor } from './health-monitor';
import { ServiceFactory } from './ServiceFactory';
import { IPluginManager } from './interfaces/IPluginManager';
import { 
  PluginData, 
  PluginManifest, 
  PluginState, 
  PluginError,
  PluginUpdateManifest 
} from '../../shared/types/plugin';
import * as fs from 'fs-extra';
import * as path from 'path';
import { PlatformUtils } from '../utils/platform';

export interface PluginRegistryConfig {\n  registryUrl: string;\n  apiKey?: string;\n  updateCheckInterval: number;\n  allowPrerelease: boolean;\n  trustedPublishers: string[];\n}\n\nexport interface PluginInstallOptions {\n  force?: boolean;\n  skipDependencies?: boolean;\n  skipSignatureCheck?: boolean;\n  installDependencies?: boolean;\n}\n\nexport interface PluginSearchResult {\n  id: string;\n  name: string;\n  version: string;\n  description: string;\n  author: string;\n  downloads: number;\n  rating: number;\n  lastUpdated: Date;\n  verified: boolean;\n}\n\nexport interface PluginManagerEvents {\n  'plugin-installed': (plugin: PluginData) => void;\n  'plugin-uninstalled': (pluginId: string) => void;\n  'plugin-enabled': (pluginId: string) => void;\n  'plugin-disabled': (pluginId: string) => void;\n  'plugin-updated': (pluginId: string, oldVersion: string, newVersion: string) => void;\n  'plugin-error': (error: PluginError) => void;\n  'plugin-health-changed': (pluginId: string, healthy: boolean) => void;\n  'registry-updated': (availableUpdates: number) => void;\n}\n\nexport class EnhancedPluginManager extends EventEmitter<PluginManagerEvents> implements IPluginManager {\n  private lifecycleManager: PluginLifecycleManager;\n  private registryConfig: PluginRegistryConfig;\n  private updateCache = new Map<string, PluginUpdateManifest>();\n  private registryUpdateInterval: NodeJS.Timeout | null = null;\n\n  constructor(\n    private corePluginManager: PluginManager,\n    private pluginSandbox: PluginSandbox,\n    private codeSigningService: PluginCodeSigningService,\n    private eventLogger: SecurityEventLogger,\n    private healthMonitor: HealthMonitor,\n    registryConfig: PluginRegistryConfig\n  ) {\n    super();\n    this.registryConfig = registryConfig;\n    \n    this.lifecycleManager = new PluginLifecycleManager(\n      this.corePluginManager,\n      this.pluginSandbox,\n      this.eventLogger,\n      this.healthMonitor\n    );\n    \n    this.setupEventListeners();\n  }\n\n  async initialize(): Promise<void> {\n    console.log('Initializing Enhanced Plugin Manager...');\n    \n    // Initialize lifecycle manager\n    await this.lifecycleManager.initialize();\n    \n    // Start registry updates\n    this.startRegistryUpdates();\n    \n    // Register with service factory\n    ServiceFactory.registerService('pluginManager', this);\n    \n    this.eventLogger.log({\n      type: 'security',\n      severity: 'low',\n      description: 'Enhanced Plugin Manager initialized',\n      timestamp: new Date(),\n      details: {\n        registryUrl: this.registryConfig.registryUrl,\n        managedPlugins: this.list().length\n      }\n    });\n  }\n\n  private setupEventListeners(): void {\n    // Forward lifecycle events\n    this.lifecycleManager.on('state-changed', (pluginId, state) => {\n      const plugin = this.get(pluginId);\n      if (plugin) {\n        plugin.state = state.state;\n        \n        switch (state.state) {\n          case 'running':\n            this.emit('plugin-enabled', pluginId);\n            break;\n          case 'stopped':\n            this.emit('plugin-disabled', pluginId);\n            break;\n          case 'error':\n            this.emit('plugin-error', {\n              pluginId,\n              message: state.error || 'Unknown error',\n              timestamp: state.timestamp,\n              recoverable: true\n            });\n            break;\n        }\n      }\n    });\n\n    this.lifecycleManager.on('health-check', (pluginId, health) => {\n      this.emit('plugin-health-changed', pluginId, health.healthy);\n    });\n\n    this.lifecycleManager.on('update-available', (pluginId, updateInfo) => {\n      this.updateCache.set(pluginId, {\n        version: updateInfo.availableVersion,\n        changelog: updateInfo.changelog || '',\n        downloadUrl: updateInfo.downloadUrl,\n        signature: updateInfo.signature || '',\n        critical: updateInfo.critical\n      });\n    });\n  }\n\n  private startRegistryUpdates(): void {\n    this.registryUpdateInterval = setInterval(async () => {\n      await this.checkRegistryUpdates();\n    }, this.registryConfig.updateCheckInterval);\n  }\n\n  private async checkRegistryUpdates(): Promise<void> {\n    try {\n      const plugins = this.list();\n      let availableUpdates = 0;\n      \n      for (const plugin of plugins) {\n        const updateInfo = await this.checkPluginUpdate(plugin.id);\n        if (updateInfo) {\n          this.updateCache.set(plugin.id, updateInfo);\n          availableUpdates++;\n        }\n      }\n      \n      this.emit('registry-updated', availableUpdates);\n      \n    } catch (error) {\n      this.eventLogger.log({\n        type: 'security',\n        severity: 'medium',\n        description: 'Registry update check failed',\n        timestamp: new Date(),\n        details: {\n          error: error instanceof Error ? error.message : String(error)\n        }\n      });\n    }\n  }\n\n  private async checkPluginUpdate(pluginId: string): Promise<PluginUpdateManifest | null> {\n    const plugin = this.get(pluginId);\n    if (!plugin) return null;\n\n    try {\n      // In a real implementation, this would query the registry\n      // For now, return null (no updates available)\n      return null;\n      \n    } catch (error) {\n      this.eventLogger.log({\n        type: 'security',\n        severity: 'low',\n        description: `Failed to check updates for plugin ${pluginId}`,\n        timestamp: new Date(),\n        details: {\n          pluginId,\n          error: error instanceof Error ? error.message : String(error)\n        }\n      });\n      return null;\n    }\n  }\n\n  // IPluginManager implementation\n  \n  async install(pluginPath: string, options: PluginInstallOptions = {}): Promise<PluginData> {\n    try {\n      // Install via lifecycle manager\n      await this.lifecycleManager.installPlugin(pluginPath);\n      \n      const plugin = this.corePluginManager.get(path.basename(pluginPath, path.extname(pluginPath)));\n      if (!plugin) {\n        throw new Error('Plugin installation failed');\n      }\n      \n      this.emit('plugin-installed', plugin);\n      return plugin;\n      \n    } catch (error) {\n      const pluginError: PluginError = {\n        pluginId: path.basename(pluginPath, path.extname(pluginPath)),\n        message: error instanceof Error ? error.message : String(error),\n        timestamp: new Date(),\n        recoverable: false\n      };\n      \n      this.emit('plugin-error', pluginError);\n      throw error;\n    }\n  }\n\n  async uninstall(pluginId: string): Promise<void> {\n    try {\n      await this.lifecycleManager.uninstallPlugin(pluginId);\n      this.emit('plugin-uninstalled', pluginId);\n      \n    } catch (error) {\n      const pluginError: PluginError = {\n        pluginId,\n        message: error instanceof Error ? error.message : String(error),\n        timestamp: new Date(),\n        recoverable: false\n      };\n      \n      this.emit('plugin-error', pluginError);\n      throw error;\n    }\n  }\n\n  async enable(pluginId: string): Promise<void> {\n    try {\n      await this.lifecycleManager.startPlugin(pluginId);\n      \n    } catch (error) {\n      const pluginError: PluginError = {\n        pluginId,\n        message: error instanceof Error ? error.message : String(error),\n        timestamp: new Date(),\n        recoverable: true\n      };\n      \n      this.emit('plugin-error', pluginError);\n      throw error;\n    }\n  }\n\n  async disable(pluginId: string): Promise<void> {\n    try {\n      await this.lifecycleManager.stopPlugin(pluginId);\n      \n    } catch (error) {\n      const pluginError: PluginError = {\n        pluginId,\n        message: error instanceof Error ? error.message : String(error),\n        timestamp: new Date(),\n        recoverable: true\n      };\n      \n      this.emit('plugin-error', pluginError);\n      throw error;\n    }\n  }\n\n  get(pluginId: string): PluginData | undefined {\n    const plugin = this.corePluginManager.get(pluginId);\n    if (plugin) {\n      // Enhance with lifecycle state\n      const state = this.lifecycleManager.getPluginState(pluginId);\n      if (state) {\n        plugin.state = state.state;\n      }\n    }\n    return plugin;\n  }\n\n  list(): PluginData[] {\n    const plugins = this.corePluginManager.list();\n    \n    // Enhance with lifecycle states\n    return plugins.map(plugin => {\n      const state = this.lifecycleManager.getPluginState(plugin.id);\n      if (state) {\n        plugin.state = state.state;\n      }\n      return plugin;\n    });\n  }\n\n  getDetails(pluginId: string): Promise<PluginData | null> {\n    return this.corePluginManager.getDetails(pluginId);\n  }\n\n  // Enhanced functionality\n  \n  async updatePlugin(pluginId: string, force: boolean = false): Promise<void> {\n    const updateInfo = this.updateCache.get(pluginId);\n    if (!updateInfo) {\n      throw new Error(`No update available for plugin ${pluginId}`);\n    }\n    \n    try {\n      await this.lifecycleManager.updatePlugin(pluginId, {\n        currentVersion: this.get(pluginId)?.version || '0.0.0',\n        availableVersion: updateInfo.version,\n        changelog: updateInfo.changelog,\n        critical: updateInfo.critical,\n        downloadUrl: updateInfo.downloadUrl,\n        signature: updateInfo.signature\n      });\n      \n      const plugin = this.get(pluginId);\n      if (plugin) {\n        this.emit('plugin-updated', pluginId, plugin.version, updateInfo.version);\n      }\n      \n    } catch (error) {\n      const pluginError: PluginError = {\n        pluginId,\n        message: error instanceof Error ? error.message : String(error),\n        timestamp: new Date(),\n        recoverable: true\n      };\n      \n      this.emit('plugin-error', pluginError);\n      throw error;\n    }\n  }\n\n  async searchPlugins(query: string, options: {\n    limit?: number;\n    offset?: number;\n    sortBy?: 'name' | 'downloads' | 'rating' | 'updated';\n    verified?: boolean;\n  } = {}): Promise<PluginSearchResult[]> {\n    try {\n      // In a real implementation, this would query the registry\n      // For now, return empty results\n      return [];\n      \n    } catch (error) {\n      this.eventLogger.log({\n        type: 'security',\n        severity: 'low',\n        description: `Plugin search failed: ${query}`,\n        timestamp: new Date(),\n        details: {\n          query,\n          error: error instanceof Error ? error.message : String(error)\n        }\n      });\n      return [];\n    }\n  }\n\n  getPluginState(pluginId: string): PluginState | undefined {\n    const state = this.lifecycleManager.getPluginState(pluginId);\n    return state?.state;\n  }\n\n  getPluginHealth(pluginId: string) {\n    return this.lifecycleManager.getPluginHealth(pluginId);\n  }\n\n  getPluginDependencies(pluginId: string) {\n    return this.lifecycleManager.getPluginDependencies(pluginId);\n  }\n\n  getAvailableUpdates(): Array<{ pluginId: string; updateInfo: PluginUpdateManifest }> {\n    return Array.from(this.updateCache.entries()).map(([pluginId, updateInfo]) => ({\n      pluginId,\n      updateInfo\n    }));\n  }\n\n  async validatePlugin(pluginPath: string): Promise<{\n    valid: boolean;\n    errors: string[];\n    warnings: string[];\n  }> {\n    const errors: string[] = [];\n    const warnings: string[] = [];\n    \n    try {\n      // Check if file exists\n      if (!await fs.pathExists(pluginPath)) {\n        errors.push('Plugin file not found');\n        return { valid: false, errors, warnings };\n      }\n      \n      // Check file size\n      const stats = await fs.stat(pluginPath);\n      if (stats.size > 100 * 1024 * 1024) { // 100MB limit\n        errors.push('Plugin file too large (max 100MB)');\n      }\n      \n      // TODO: Add more validation (manifest, signatures, etc.)\n      \n      return {\n        valid: errors.length === 0,\n        errors,\n        warnings\n      };\n      \n    } catch (error) {\n      errors.push(`Validation failed: ${error instanceof Error ? error.message : String(error)}`);\n      return { valid: false, errors, warnings };\n    }\n  }\n\n  async exportPlugin(pluginId: string, exportPath: string): Promise<void> {\n    const plugin = this.get(pluginId);\n    if (!plugin) {\n      throw new Error(`Plugin ${pluginId} not found`);\n    }\n    \n    try {\n      const pluginDir = path.join(PlatformUtils.getPluginsPath(), pluginId);\n      \n      // Create export archive\n      // In a real implementation, this would create a proper plugin archive\n      await fs.copy(pluginDir, exportPath);\n      \n      this.eventLogger.log({\n        type: 'security',\n        severity: 'low',\n        description: `Plugin exported: ${pluginId}`,\n        timestamp: new Date(),\n        details: { pluginId, exportPath }\n      });\n      \n    } catch (error) {\n      throw new Error(`Export failed: ${error instanceof Error ? error.message : String(error)}`);\n    }\n  }\n\n  async getPluginLogs(pluginId: string, options: {\n    limit?: number;\n    since?: Date;\n    level?: 'error' | 'warn' | 'info' | 'debug';\n  } = {}): Promise<Array<{\n    timestamp: Date;\n    level: string;\n    message: string;\n    details?: any;\n  }>> {\n    // In a real implementation, this would query plugin-specific logs\n    // For now, return empty array\n    return [];\n  }\n\n  async clearPluginData(pluginId: string): Promise<void> {\n    const plugin = this.get(pluginId);\n    if (!plugin) {\n      throw new Error(`Plugin ${pluginId} not found`);\n    }\n    \n    try {\n      const pluginDataDir = path.join(PlatformUtils.getPluginsPath(), pluginId, 'data');\n      if (await fs.pathExists(pluginDataDir)) {\n        await fs.emptyDir(pluginDataDir);\n      }\n      \n      this.eventLogger.log({\n        type: 'security',\n        severity: 'low',\n        description: `Plugin data cleared: ${pluginId}`,\n        timestamp: new Date(),\n        details: { pluginId }\n      });\n      \n    } catch (error) {\n      throw new Error(`Clear data failed: ${error instanceof Error ? error.message : String(error)}`);\n    }\n  }\n\n  async shutdown(): Promise<void> {\n    if (this.registryUpdateInterval) {\n      clearInterval(this.registryUpdateInterval);\n    }\n    \n    await this.lifecycleManager.shutdown();\n    \n    this.eventLogger.log({\n      type: 'security',\n      severity: 'low',\n      description: 'Enhanced Plugin Manager shutdown completed',\n      timestamp: new Date(),\n      details: {}\n    });\n  }\n\n  // Configuration methods\n  \n  updateRegistryConfig(config: Partial<PluginRegistryConfig>): void {\n    this.registryConfig = { ...this.registryConfig, ...config };\n    \n    // Restart registry updates with new config\n    if (this.registryUpdateInterval) {\n      clearInterval(this.registryUpdateInterval);\n      this.startRegistryUpdates();\n    }\n  }\n\n  getRegistryConfig(): PluginRegistryConfig {\n    return { ...this.registryConfig };\n  }\n\n  getStatistics(): {\n    totalPlugins: number;\n    enabledPlugins: number;\n    runningPlugins: number;\n    errorPlugins: number;\n    availableUpdates: number;\n    totalErrors: number;\n    healthyPlugins: number;\n  } {\n    const plugins = this.list();\n    \n    return {\n      totalPlugins: plugins.length,\n      enabledPlugins: plugins.filter(p => p.enabled).length,\n      runningPlugins: plugins.filter(p => p.state === 'running').length,\n      errorPlugins: plugins.filter(p => p.state === 'error').length,\n      availableUpdates: this.updateCache.size,\n      totalErrors: plugins.reduce((sum, p) => {\n        const health = this.getPluginHealth(p.id);\n        return sum + (health?.errors || 0);\n      }, 0),\n      healthyPlugins: plugins.filter(p => {\n        const health = this.getPluginHealth(p.id);\n        return health?.healthy !== false;\n      }).length\n    };\n  }\n}